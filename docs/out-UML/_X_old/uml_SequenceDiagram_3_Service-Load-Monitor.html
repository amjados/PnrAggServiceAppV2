<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Option 3: Service with Auto-Scaling</title>
<script type="module">
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
mermaid.initialize({ startOnLoad: true });
</script>
<style>
body { 
    font-family: Arial, sans-serif; 
    background: #fff; 
    padding: 20px;
    margin: 0;
}
.container { 
    max-width: 1200px; 
    margin: 0 auto;
}
h2 { 
    color: #2c3e50;
    margin-top: 0;
    font-size: 22px;
}
.mermaid { 
    background: #fafafa; 
    padding: 20px; 
    border-radius: 8px; 
    border: 1px solid #ddd;
    margin: 20px 0;
}
.note {
    background: #f8f9fa;
    border-left: 4px solid #667eea;
    padding: 15px;
    margin: 20px 0;
    border-radius: 4px;
}
.summary {
    margin: 20px 0;
    padding: 15px;
    background: #fafafa;
    border-radius: 8px;
    border: 1px solid #ddd;
}
.summary h3 {
    margin-top: 0;
    color: #2c3e50;
    font-size: 18px;
}
.pros {
    color: #2e7d32;
}
.cons {
    color: #c62828;
}
ul {
    line-height: 1.8;
    margin: 10px 0;
}
</style>
</head>
<body>
<div class="container">

<h2>Option 3: Service with Auto-Scaling (Dynamic Architecture)</h2>

<p>Service architecture enhanced with LoadMonitorVerticle for automatic horizontal scaling based on actual request load metrics.</p>

<div class="mermaid">
sequenceDiagram
    autonumber

    actor Client
    participant C as BookingController
    participant EB as EventBus
    participant V as BookingVerticle<br/>(Instance #3)
    participant AGG as BookingAggregatorService
    participant TS as TripService
    participant BS as BaggageService
    participant TK as TicketService
    participant DB as MongoDB
    participant MON as LoadMonitorVerticle

    Client->>C: GET /booking/{pnr}
    Note over C: Check config:<br/>useEventBus = true

    C->>EB: request("pnr.fetch", pnr)
    Note over EB: Round-robin distribution<br/>to available instances

    EB->>V: deliver to instance #3

    V->>V: incrementRequestCount()
    V->>EB: publish("booking.metrics",<br/>{instanceId: 3, requestCount: 47})

    Note over V: Delegate to service layer
    V->>AGG: aggregateBooking(pnr)

    par Parallel: Trip & Baggage
        AGG->>TS: getTripInfo(pnr)
        TS->>DB: find("trips")
        DB-->>TS: trip
        TS-->>AGG: Trip
    and
        AGG->>BS: getBaggage(pnr)
        BS->>DB: find("baggage")
        DB-->>BS: baggage
        BS-->>AGG: Baggage
    end

    loop For each passenger (parallel)
        AGG->>TK: getTicket(pnr, passengerNumber)
        TK->>DB: find("tickets")
        DB-->>TK: ticket OR null
        TK-->>AGG: Ticket
    end

    AGG->>AGG: merge data
    AGG-->>V: BookingResponse

    V->>EB: reply(response)
    EB-->>C: response
    C-->>Client: HTTP 200 + Response

    Note over MON: Every 30 seconds
    EB->>MON: consume("booking.metrics")
    MON->>MON: analyzeLoad()<br/>avgRequests = 120/instance<br/>(threshold: 100)

    alt Load > Threshold
        MON->>EB: deploy(BookingVerticle, instances=2)
        Note over MON: Scale UP from 5 to 7 instances
    else Load < Threshold
        MON->>EB: undeploy(deploymentId)
        Note over MON: Scale DOWN from 7 to 5 instances
    end
</div>

<div class="note">
    <strong>Architecture Pattern:</strong> LoadMonitorVerticle monitors EventBus metrics and dynamically scales BookingVerticle instances from 1 to 10 based on request load. Each verticle delegates to existing service layer, maintaining clean architecture while enabling horizontal scaling.
</div>

<div class="note">
    <strong>Key Insight:</strong> Services remain unchanged - BookingVerticle is a thin wrapper that delegates to BookingAggregatorService. This preserves clean service architecture while adding auto-scaling capability through EventBus pattern.
</div>

<div class="summary">
    <h3 class="pros">✓ Advantages</h3>
    <ul>
        <li><strong>Automatic Scaling:</strong> Dynamically scales from 1 to 10 instances based on actual load</li>
        <li><strong>Load Distribution:</strong> EventBus provides built-in round-robin message distribution</li>
        <li><strong>Handles Traffic Spikes:</strong> Automatically adds instances when load increases</li>
        <li><strong>Cost Efficient:</strong> Scales down during low traffic to save resources</li>
        <li><strong>Clean Service Layer:</strong> Services unchanged, verticle is thin delegation wrapper</li>
        <li><strong>Real-Time Metrics:</strong> Monitors actual request counts per instance</li>
    </ul>
</div>

<div class="summary">
    <h3 class="cons">✗ Limitations</h3>
    <ul>
        <li><strong>EventBus Overhead:</strong> Additional 5-10ms latency per request through EventBus</li>
        <li><strong>Increased Complexity:</strong> Requires LoadMonitorVerticle and BookingVerticle components</li>
        <li><strong>Configuration Tuning:</strong> Thresholds need adjustment for optimal scaling behavior</li>
        <li><strong>Single Machine Limit:</strong> Scales verticle instances within single JVM only</li>
        <li><strong>No Failure Protection:</strong> Still needs circuit breaker for MongoDB failure handling</li>
    </ul>
</div>

</div>
</body>
</html>
