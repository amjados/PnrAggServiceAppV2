<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Option 1: Direct Service Calls</title>
<script type="module">
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
mermaid.initialize({ startOnLoad: true });
</script>
<style>
body { 
    font-family: Arial, sans-serif; 
    background: #fff; 
    padding: 20px;
    margin: 0;
}
.container { 
    max-width: 1200px; 
    margin: 0 auto;
}
h2 { 
    color: #2c3e50;
    margin-top: 0;
    font-size: 22px;
}
.mermaid { 
    background: #fafafa; 
    padding: 20px; 
    border-radius: 8px; 
    border: 1px solid #ddd;
    margin: 20px 0;
}
.note {
    background: #f8f9fa;
    border-left: 4px solid #667eea;
    padding: 15px;
    margin: 20px 0;
    border-radius: 4px;
}
.summary {
    margin: 20px 0;
    padding: 15px;
    background: #fafafa;
    border-radius: 8px;
    border: 1px solid #ddd;
}
.summary h3 {
    margin-top: 0;
    color: #2c3e50;
    font-size: 18px;
}
.pros {
    color: #2e7d32;
}
.cons {
    color: #c62828;
}
ul {
    line-height: 1.8;
    margin: 10px 0;
}
</style>
</head>
<body>
<div class="container">

<h2>Option 1: Direct Service Calls (Simple Architecture)</h2>

<p>Clean service-only architecture where all reactive logic lives inside Spring Services with direct MongoDB access.</p>

<div class="mermaid">
sequenceDiagram
    autonumber

    actor Client
    participant C as BookingController
    participant AGG as BookingAggregatorService
    participant TS as TripService
    participant BS as BaggageService
    participant TK as TicketService
    participant DB as MongoDB
    participant EB as EventBus

    Client->>C: GET /booking/{pnr}
    C->>AGG: aggregateBooking(pnr)

    par Parallel: Trip & Baggage
        AGG->>TS: getTripInfo(pnr)
        TS->>DB: find("trips", {bookingReference: pnr})
        DB-->>TS: trip document
        TS-->>AGG: Trip data
    and
        AGG->>BS: getBaggage(pnr)
        BS->>DB: find("baggage", {bookingReference: pnr})
        DB-->>BS: baggage document
        BS-->>AGG: Baggage data
    end

    loop For each passenger (parallel)
        AGG->>TK: getTicket(pnr, passengerNumber)
        TK->>DB: find("tickets", {pnr, passengerNumber})
        DB-->>TK: ticket OR null
        TK-->>AGG: Ticket data
    end

    AGG->>AGG: merge(trip, baggage, tickets)
    AGG->>EB: publish("pnr.fetched")

    AGG-->>C: BookingResponse JSON
    C-->>Client: HTTP 200 + Response
</div>

<div class="note">
    <strong>Architecture Pattern:</strong> Direct service calls with parallel execution using Vert.x Futures. Trip and Baggage data fetched simultaneously, followed by parallel ticket queries for all passengers. Missing tickets handled gracefully with .recover() pattern.
</div>

<div class="summary">
    <h3 class="pros">✓ Advantages</h3>
    <ul>
        <li><strong>Simple Implementation:</strong> Straightforward architecture with minimal complexity</li>
        <li><strong>Fast Development:</strong> Quick to implement and understand</li>
        <li><strong>Easy Debugging:</strong> Direct call path makes troubleshooting simple</li>
        <li><strong>Good Performance:</strong> Parallel execution for Trip, Baggage, and Tickets</li>
        <li><strong>Low Resource Usage:</strong> No additional infrastructure needed</li>
    </ul>
</div>

<div class="summary">
    <h3 class="cons">✗ Limitations</h3>
    <ul>
        <li><strong>No Failure Protection:</strong> MongoDB failures cause complete request failure</li>
        <li><strong>No Graceful Degradation:</strong> Cannot return partial data when services fail</li>
        <li><strong>No Auto-Scaling:</strong> Manual horizontal scaling only</li>
        <li><strong>Cascading Failures:</strong> One service failure can block entire request</li>
        <li><strong>No Fallback Mechanism:</strong> No cached or default data when database is unavailable</li>
    </ul>
</div>

</div>
</body>
</html>
