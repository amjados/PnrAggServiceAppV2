<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Option 2: Service with Circuit Breaker</title>
<script type="module">
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
mermaid.initialize({ startOnLoad: true });
</script>
<style>
body { 
    font-family: Arial, sans-serif; 
    background: #fff; 
    padding: 20px;
    margin: 0;
}
.container { 
    max-width: 1200px; 
    margin: 0 auto;
}
h2 { 
    color: #2c3e50;
    margin-top: 0;
    font-size: 22px;
}
.mermaid { 
    background: #fafafa; 
    padding: 20px; 
    border-radius: 8px; 
    border: 1px solid #ddd;
    margin: 20px 0;
}
.note {
    background: #f8f9fa;
    border-left: 4px solid #667eea;
    padding: 15px;
    margin: 20px 0;
    border-radius: 4px;
}
.summary {
    margin: 20px 0;
    padding: 15px;
    background: #fafafa;
    border-radius: 8px;
    border: 1px solid #ddd;
}
.summary h3 {
    margin-top: 0;
    color: #2c3e50;
    font-size: 18px;
}
.pros {
    color: #2e7d32;
}
.cons {
    color: #c62828;
}
ul {
    line-height: 1.8;
    margin: 10px 0;
}
</style>
</head>
<body>
<div class="container">

<h2>Option 2: Service with Circuit Breaker (Resilient Architecture)</h2>

<p>Service architecture enhanced with circuit breaker pattern to prevent cascading failures and enable graceful degradation.</p>

<div class="mermaid">
sequenceDiagram
    autonumber

    actor Client
    participant C as BookingController
    participant AGG as BookingAggregatorService
    participant TS as TripService
    participant CB1 as Circuit Breaker<br/>(TripService)
    participant BS as BaggageService
    participant CB2 as Circuit Breaker<br/>(BaggageService)
    participant TK as TicketService
    participant CB3 as Circuit Breaker<br/>(TicketService)
    participant DB as MongoDB
    participant EB as EventBus

    Client->>C: GET /booking/{pnr}
    C->>AGG: aggregateBooking(pnr)

    par Parallel: Trip & Baggage
        AGG->>TS: getTripInfo(pnr)
        TS->>CB1: Check circuit state
        Note over CB1: State: CLOSED<br/>Allow request
        CB1->>DB: find("trips")
        DB-->>CB1: trip document
        Note over CB1: Success recorded
        CB1-->>TS: trip data
        TS-->>AGG: Trip
    and
        AGG->>BS: getBaggage(pnr)
        BS->>CB2: Check circuit state
        Note over CB2: State: CLOSED<br/>Allow request
        CB2->>DB: find("baggage")
        DB-->>CB2: baggage document
        Note over CB2: Success recorded
        CB2-->>BS: baggage data
        BS-->>AGG: Baggage
    end

    loop For each passenger (parallel)
        AGG->>TK: getTicket(pnr, passengerNumber)
        TK->>CB3: Check circuit state
        Note over CB3: State: CLOSED<br/>Allow request
        CB3->>DB: find("tickets")
        DB-->>CB3: ticket OR null
        CB3-->>TK: ticket data
        TK-->>AGG: Ticket
    end

    AGG->>AGG: merge(trip, baggage, tickets)
    AGG->>EB: publish("pnr.fetched")

    AGG-->>C: BookingResponse JSON
    C-->>Client: HTTP 200 + Response
</div>

<div class="note">
    <strong>Architecture Pattern:</strong> Circuit breaker wraps MongoDB calls in each service to prevent cascading failures. Each service has independent circuit breaker monitoring connection health. When failures exceed threshold, circuit opens and fallback methods provide cached or default data.
</div>

<div class="note">
    <strong>Key Insight:</strong> Each service has its own circuit breaker. If BaggageService fails, TripService and TicketService continue working. This allows graceful degradation - partial data is better than complete failure.
</div>

<div class="summary">
    <h3 class="pros">✓ Advantages</h3>
    <ul>
        <li><strong>Failure Protection:</strong> Circuit breaker prevents cascading failures when MongoDB is down</li>
        <li><strong>Graceful Degradation:</strong> Returns cached or default data instead of complete failure</li>
        <li><strong>Independent Services:</strong> Each service fails independently without affecting others</li>
        <li><strong>Auto-Recovery:</strong> Circuit automatically tests and recovers after failure period</li>
        <li><strong>Fast Failure Response:</strong> Immediate fallback instead of waiting for timeouts</li>
        <li><strong>Production Ready:</strong> Proven resilience pattern for microservices</li>
    </ul>
</div>

<div class="summary">
    <h3 class="cons">✗ Limitations</h3>
    <ul>
        <li><strong>Increased Complexity:</strong> More configuration and fallback logic required</li>
        <li><strong>Caching Required:</strong> Need cache infrastructure for fallback data</li>
        <li><strong>Stale Data Risk:</strong> Fallback may return outdated cached information</li>
        <li><strong>Additional Dependencies:</strong> Requires Resilience4j library and cache manager</li>
        <li><strong>No Auto-Scaling:</strong> Still requires manual horizontal scaling</li>
    </ul>
</div>

</div>
</body>
</html>
